### 高并发
1. synchronized

2. ReentrantLock

3. ReentrantReadWriteLock

4. 锁优化

5. java虚拟机对锁的优化

6. 无锁

7. 解决死锁

   1. ##### **synchronized**

      1. ##### 简介

          ##### 在加了 syncronized 关键字的方法、代码块中，一次只允许一个线程进入特定代码段，从而避免多线程同时修改同一数据。
          
      2. ##### 锁升级

          <img src="https://wx2.sbimg.cn/2020/07/29/P06b1.png" style="zoom:67%;" />

          - ##### **偏向锁**

            在 JDK1.8 中，其实默认是轻量级锁，但如果设定了 -XX:BiasedLockingStartupDelay = 0 ，那在对一个 Object 做 syncronized 的时候，会立即上一把偏向锁。当处于偏向锁状态时， markwork 会记录当前线程 ID 。

          - ##### **升级到轻量级锁**

            当下一个线程参与到偏向锁竞争时，会先判断 markword 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁。每个线程在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS (自旋)的操作将锁对象头中的 markwork 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着获得锁。

          - ##### **升级到重量级锁**

            如果锁竞争加剧(如线程自旋次数或者自旋的线程数超过某阈值， JDK1.6 之后，由 JVM 自己控制该规则)，就会升级为重量级锁。此时就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。在重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是"重"的原因之一。

          - ##### **可重入**

            synchronized 拥有强制原子性的内部锁机制，是一把可重入锁。因此，在一个线程使用 synchronized 方法时调用该对象另一个 synchronized 方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的。在 Java 中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。 synchronized 锁的对象头的 markwork 中会记录该锁的线程持有者和计数器，当一个线程请求成功后， JVM 会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized 方法/块时，计数器会递减，如果计数器为 0 则释放该锁锁。

          - ##### **悲观锁(互斥锁、排他锁)**

             synchronized 是一把悲观锁(独占锁)，当前线程如果获取到锁，会导致其它所有需要锁该的线程等待，一直等待持有锁的线程释放锁才继续进行锁的争抢。

   2. ##### **ReentrantLock**

      ##### 实现原理也与 syncronized 有很大差别，它是基于经典的 AQS(AbstractQueueSyncronized) 实现的, AQS 是基于 volitale 和 CAS 实现的，其中 AQS 中维护一个 valitale 类型的变量 state 来做一个可重入锁的重入次数，加锁和释放锁也是围绕这个变量来进行的。 ReentrantLock 也提供了一些 synchronized 没有的特点，因此比 synchronized 好用。

      - ##### **可重入**

        #####  ReentrantLock 和 syncronized 关键字一样，都是可重入锁，不过两者实现原理稍有差别， RetrantLock 利用 AQS 的的 state 状态来判断资源是否已锁，同一线程重入加锁， state 的状态 +1 ; 同一线程重入解锁, state 状态 -1 (解锁必须为当前独占线程，否则异常); 当 state 为 0 时解锁成功。

      - ##### **需要手动加锁**、解锁

        ##### ynchronized 关键字是自动进行加锁、解锁的，而 ReentrantLock 需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成，来手动加锁、解锁。

      - ##### **支持设置锁的超时时间**

        ##### synchronized 关键字无法设置锁的超时时间，如果一个获得锁的线程内部发生死锁，那么其他线程就会一直进入阻塞状态，而 ReentrantLock 提供 tryLock 方法，允许设置线程获取锁的超时时间，如果超时，则跳过，不进行任何操作，避免死锁的发生。

      - ##### 支持公平/非公平锁

        ##### synchronized 关键字是一种非公平锁，先抢到锁的线程先执行。而 ReentrantLock 的构造方法中允许设置 true/false 来实现公平、非公平锁，如果设置为 true ，则线程获取锁要遵循"先来后到"的规则，每次都会构造一个线程 Node ，然后到双向链表的"尾巴"后面排队，等待前面的 Node 释放锁资源。

      - ##### **可中断锁**

        #####  ReentrantLock 中的 lockInterruptibly() 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 interrupt() 方法就可以立刻打断 t1 线程的执行，来获取t1持有的那个可重入锁。而通过 ReentrantLock 的 lock() 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt() 方法的，直到该方法主动释放锁之后才会响应 interrupt() 方法。

   3. ##### **ReentrantReadWriteLock**

      ##### ReentrantReadWriteLock (读写锁)其实是两把锁，一把是 WriteLock (写锁)，一把是读锁， ReadLock 。

    4. ##### **锁优化**
       1. 减少锁持有的时间（减少同步的代码，不用同步的就不同步）

       2. 减小锁粒度（比如一个HashMap被划分成16端，数据要插入那段就获取那段的表）

       3. 读写分离锁来替换独占锁
         
       4. 锁分离（比如链表，在表头加数据和在表尾加数据是不影响的，可以使用两把锁，分别给这2个写操作持有）
         
       5. 锁粗化（把多个锁的请求和成一个锁）

          ```
           //本来要2个synchronized来给代码加锁，但是为少锁的请求消耗性能，所以整合成一个锁
           public void demoMethod(){
           	      synchronized(lock){
           		  //同步的代码
            		  //不需要同步的代码，但是为了整合成一个锁，也把他加进来
            		  //同步的代码
            	        }
              }
          ```

            ```
              for(int i=0;i<10;i++){
                synchronized(lock){}
               }
               //改成,减少锁的请求次数
               synchronized(lock){
                 for(int i=0;i<10;i++){}
                }
            ```

   5. **java虚拟机对锁的优化**

      - 锁偏向（默认开启，java虚拟机参数 -XX:-UseBiasedLocking 开启）

        无实际竞争，且将来只有第一个申请锁的线程会使用锁时将会使用，偏向锁只有初始化时需要一次CAS。

        缺点：如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。

        

      - 轻量级锁

        无实际竞争，多个线程交替使用锁；允许短时间的锁竞争是会开启使用。轻量级锁每次申请、释放锁都至少需要一次CAS。

        

      - 自旋锁（使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。）

        锁膨胀后，为避免线程真实挂起，虚拟机会让当前线程做几个空for循环后，如果还不能获得锁就会挂起

        

      - 重量级锁

        有实际竞争，且锁竞争时间长。

        如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。

        

      - 锁消除

        java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。

   6. **无锁**

      对于并发而言，锁是一种悲观的策略。而无锁是一种乐观的策略。

      - 比较交换（CAS）

        CAS需要你额外给给出一个期望值。如果变量不是这样，那说明被人修改过。你需要重新读取，再次尝试修改。

      - 无锁的线程安全整数 AtomicInteger

        对其的任何修改都是用CAS指令的

      - 无锁线程安全数组 AtomicIntegerArray

   7. **解决死锁**

      使用jps命令得到java进程的教程ID，接着使用jstack命令得到线程的线程堆栈，然后在屏幕上找到Found one Java-level deadlock：

